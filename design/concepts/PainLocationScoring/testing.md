# prompt: Modify the console messages and testing results of the PainLocationScoring test suite to look more user-friendly, clean, and readable like the BodyMapGeneration test suite. Do not display the entire id of each map and region, simply abstract them to representative Strings when printing. Ensure that all of the arguments and results of your actions are either primitive values (strings, numbers, etc) or object identifiers (actually document identifiers in MongoDB). Composite objects should be used only inside concept implementations and never exposed.

[@BodyMapGeneration](../../../src/concepts/BodyMapGeneration/BodyMapGeneration.test.ts)
[@PainLocationScoring](../../../src/concepts/PainLocationScoring/PainLocationScoringConcept.test.ts)

# response: 

<!-- # prompt: You are given an example Deno test suite for a LikertSurvey concept implementation. Use it as a model for how to structure and phrase tests — including the principles, action requirements, use of testDb(), assertions (assertEquals, assertNotEquals, etc.), and clean test isolation via client.close(). Now, write a complete Deno test suite for the given PainLocationScoring implementation. Explicitly call generateMap() from BodyMapGeneration and use the result to test PainLocationScoring. Do NOT internally create any maps as a part of PainLocationScoring. 

[@PainLocationScoringTesting](../../background/PainLocationScoringTesting.md)

[@testing-concepts](../../background/testing-concepts.md)

[@LikertSurveyTesting-Example](../LikertSurvey/testing.md)

[@PainLocationScoringImplementation](../../../src/concepts/PainLocationScoring/PainLocationScoringConcept.ts)

[@BodyMapGeneration](../../../src/concepts/BodyMapGeneration/BodyMapGeneration.ts) -->


# response:

```typescript
import { assertEquals, assertExists, assertNotEquals } from "jsr:@std/assert";
import { testDb } from "@utils/database.ts";
import { ID } from "@utils/types.ts";
import PainLocationScoringConcept from "./PainLocationScoringConcept.ts";
import BodyMapGenerationConcept from "../BodyMapGeneration/BodyMapGeneration.ts";

// Define generic user IDs for testing
const userA = "user:Alice" as ID;
const userB = "user:Bob" as ID;

// Global counters and maps for friendly names across test steps within a Deno.test block
let globalMapCounter = 0;
let globalRegionCounter = 0;
const idToFriendlyMapName = new Map<ID, string>();
const idToFriendlyRegionName = new Map<ID, string>();

/**
 * Helper to get a short, representative string for an ID in console output.
 * If the ID is a known test alias (like "user:Alice" or "map:nonexistent"), use that directly.
 * Otherwise, generate a consistent friendly name (e.g., 'Map-1', 'Region-2') for long DB-generated IDs.
 * @param id The actual ID (e.g., MongoDB ObjectID string).
 * @param type 'map' or 'region'
 * @param preferredName Optional descriptive name for a region (e.g., "Left Knee")
 * @returns A friendly string for console output, prefixed with single quotes for clarity.
 */
function getAbstractedId(id: ID, type: 'map' | 'region', preferredName?: string): string {
  // Directly use predefined short IDs or non-DB IDs for clarity
  if (id.startsWith("map:") || id.startsWith("region:") || id.startsWith("user:")) {
    return `'${id}'`;
  }

  // For DB-generated IDs, use stored friendly names or generate new ones
  if (type === 'map') {
    if (!idToFriendlyMapName.has(id)) {
      idToFriendlyMapName.set(id, `Map-${++globalMapCounter}`);
    }
    return `'${idToFriendlyMapName.get(id)!}'`;
  } else if (type === 'region') {
    if (!idToFriendlyRegionName.has(id)) {
      // Use preferredName if provided, otherwise generate a generic region name
      idToFriendlyRegionName.set(id, preferredName ? `${preferredName}` : `Region-${++globalRegionCounter}`);
    }
    // Append preferred name to generic region name if not already used as primary name
    const friendlyName = idToFriendlyRegionName.get(id)!;
    if (preferredName && friendlyName !== preferredName) {
      return `'${friendlyName} (${preferredName})'`;
    }
    return `'${friendlyName}'`;
  }
  return `'${id}'`; // Fallback, should not be reached for 'map' or 'region' types
}

/**
 * Helper function to simulate the integrated process of generating a map via
 * BodyMapGeneration and then making PainLocationScoringConcept aware of it
 * for its internal ownership validation.
 * This simulates the effect of a synchronization rule where PainLocationScoring
 * becomes aware of maps generated by BodyMapGeneration.
 *
 * @param bodyMapGen The BodyMapGenerationConcept instance.
 * @param painScoreConcept The PainLocationScoringConcept instance.
 * @param user The user ID for whom the map is generated.
 * @returns The ID of the generated map.
 */
async function setupMap(
  bodyMapGen: BodyMapGenerationConcept,
  painScoreConcept: PainLocationScoringConcept,
  user: ID,
): Promise<ID> {
  // 1. Generate map via BodyMapGeneration
  const generateMapResult = await bodyMapGen.generateMap({ user });
  assertNotEquals("error" in generateMapResult, true, `Map generation for '${user}' should succeed.`);
  const { mapId } = generateMapResult as { mapId: ID };
  const mapFriendlyName = getAbstractedId(mapId, 'map');

  console.log(`  Setup: Generating map for user '${user}'. Friendly ID: ${mapFriendlyName}`);

  // 2. Register this map with PainLocationScoring for its internal validation.
  // This uses the _addMapForTesting helper, acting as a mock for a cross-concept sync.
  const registerMapResult = await painScoreConcept._addMapForTesting({ user, map: mapId });
  assertEquals("error" in registerMapResult, false, `Setup: Registering map ${mapFriendlyName} with PainLocationScoring for user '${user}' should succeed.`);
  console.log(`  Setup: Registered map ${mapFriendlyName} with PainLocationScoring.`);
  return mapId; // Still return the actual ID for internal logic and assertions
}

Deno.test("PainLocationScoring", async (test) => {
  // Reset counters and maps for a clean start to this overall test suite
  globalMapCounter = 0;
  globalRegionCounter = 0;
  idToFriendlyMapName.clear();
  idToFriendlyRegionName.clear();

  await test.step("Principle: Generate map → add region → score region → delete region → verify state at each step", async () => {
    const [db, client] = await testDb();
    const bodyMapGen = new BodyMapGenerationConcept(db);
    const painScoreConcept = new PainLocationScoringConcept(db);

    try {
      console.log("\n--- Principle: PainLocationScoring Lifecycle ---");

      // Action: Generate map for User A using BodyMapGeneration
      console.log(`  Principle: Generating and registering a map for user '${userA}'.`);
      const mapA = await setupMap(bodyMapGen, painScoreConcept, userA);
      assertExists(mapA, "A map ID should be returned for user A.");
      const mapAFriendly = getAbstractedId(mapA, 'map');
      console.log(`  Output: Map ${mapAFriendly} created for user '${userA}'.`);

      // Action: Add a region to User A's map
      const regionName = "Left Knee";
      console.log(`  Principle: Adding region '${regionName}' to map ${mapAFriendly} for user '${userA}'.`);
      const addRegionResult = await painScoreConcept.addRegion({ user: userA, map: mapA, regionName });
      assertNotEquals("error" in addRegionResult, true, "addRegion should not fail.");
      const { region: regionA } = addRegionResult as { region: ID };
      assertExists(regionA, "A region ID should be returned.");
      const regionAFriendly = getAbstractedId(regionA, 'region', regionName);
      console.log(`  Output: New region created with friendly ID: ${regionAFriendly}.`);

      // Verification: The region was added
      console.log(`  Principle: Verifying region ${regionAFriendly} was added to map ${mapAFriendly}.`);
      const regionsAfterAdd = await painScoreConcept._getRegionsForMap({ user: userA, map: mapA });
      assertNotEquals("error" in regionsAfterAdd, true, "_getRegionsForMap should not fail.");
      assertEquals((regionsAfterAdd as Array<any>).length, 1, "There should be exactly one region after adding.");
      assertEquals((regionsAfterAdd as Array<any>)[0]._id, regionA, `The added region's ID should match ${regionAFriendly}.`);
      assertEquals((regionsAfterAdd as Array<any>)[0].name, regionName, `The added region's name should match '${regionName}'.`);
      console.log(`  Verification: Region ${regionAFriendly} successfully added to map ${mapAFriendly}.`);

      // Action: Score the region for User A
      const scoreValue = 7;
      console.log(`  Principle: Scoring region ${regionAFriendly} with value ${scoreValue} for user '${userA}'.`);
      const scoreRegionResult = await painScoreConcept.scoreRegion({ user: userA, region: regionA, score: scoreValue });
      assertEquals("error" in scoreRegionResult, false, "scoreRegion should succeed.");
      console.log(`  Output: Region ${regionAFriendly} scored with ${scoreValue}.`);

      // Verification: The score was applied
      console.log(`  Principle: Verifying score for region ${regionAFriendly}.`);
      const scoredRegion = await painScoreConcept._getRegion({ user: userA, region: regionA });
      assertNotEquals("error" in scoredRegion, true, "_getRegion should not fail after scoring.");
      assertEquals((scoredRegion as Array<any>).length, 1, "The scored region should be found.");
      assertEquals((scoredRegion as Array<any>)[0].score, scoreValue, `The region's score should be ${scoreValue}.`);
      console.log(`  Verification: Region ${regionAFriendly} now has score ${scoreValue}.`);

      // Action: Delete the region for User A
      console.log(`  Principle: Deleting region ${regionAFriendly} for user '${userA}'.`);
      const deleteRegionResult = await painScoreConcept.deleteRegion({ user: userA, region: regionA });
      assertEquals("error" in deleteRegionResult, false, "deleteRegion should succeed.");
      console.log(`  Output: Region ${regionAFriendly} deleted.`);

      // Verification: The region is deleted
      console.log(`  Principle: Verifying region ${regionAFriendly} is deleted from map ${mapAFriendly}.`);
      const regionsAfterDelete = await painScoreConcept._getRegionsForMap({ user: userA, map: mapA });
      assertNotEquals("error" in regionsAfterDelete, true, "_getRegionsForMap should not fail after deletion attempt.");
      assertEquals((regionsAfterDelete as Array<any>).length, 0, "There should be no regions after deletion.");
      console.log(`  Verification: Region ${regionAFriendly} successfully deleted from map ${mapAFriendly}.`);

      console.log("--- Principle: PainLocationScoring Lifecycle Complete ---");
    } finally {
      await client.close();
    }
  });

  await test.step("Action: addRegion requirements and effects", async () => {
    const [db, client] = await testDb();
    const bodyMapGen = new BodyMapGenerationConcept(db);
    const painScoreConcept = new PainLocationScoringConcept(db);

    try {
      console.log("\n--- Action: addRegion Tests Start ---");

      // Setup: Generate maps for userA and userB and register them
      console.log(`  Setup: Initializing maps for user '${userA}' and user '${userB}'.`);
      const mapA = await setupMap(bodyMapGen, painScoreConcept, userA);
      const mapB = await setupMap(bodyMapGen, painScoreConcept, userB);
      const mapAFriendly = getAbstractedId(mapA, 'map');
      const mapBFriendly = getAbstractedId(mapB, 'map');
      assertExists(mapA, "mapA should be available.");
      assertExists(mapB, "mapB should be available.");
      console.log(`  Output: Map ${mapAFriendly} for '${userA}', Map ${mapBFriendly} for '${userB}'.`);

      // Test Case 1: Add region to a non-existent map ID
      const nonExistentMap = "map:nonexistent" as ID;
      const nonExistentMapFriendly = getAbstractedId(nonExistentMap, 'map');
      console.log(`  Action: User '${userA}' attempts to add region to non-existent map ${nonExistentMapFriendly}.`);
      const result1 = await painScoreConcept.addRegion({ user: userA, map: nonExistentMap, regionName: "Phantom Limb" });
      assertEquals("error" in result1, true, "Expected error when adding to non-existent map.");
      assertEquals((result1 as { error: string }).error, `Map '${nonExistentMap}' not found for user '${userA}' or user does not own it.`, "Error message mismatch for non-existent map.");
      console.log(`  Output: Error received: '${(result1 as { error: string }).error}' (Expected)`);

      // Test Case 2: Add region to a map not owned by the specified user
      console.log(`  Action: User '${userA}' attempts to add region to map ${mapBFriendly} owned by '${userB}'.`);
      const result2 = await painScoreConcept.addRegion({ user: userA, map: mapB, regionName: "Stolen Map Region" });
      assertEquals("error" in result2, true, "Expected error when adding to another user's map.");
      assertEquals((result2 as { error: string }).error, `Map '${mapB}' not found for user '${userA}' or user does not own it.`, "Error message mismatch for unowned map.");
      console.log(`  Output: Error received: '${(result2 as { error: string }).error}' (Expected)`);

      // Test Case 3: Successfully add a region to an owned map
      const regionNameSuccess = "Right Shoulder";
      console.log(`  Action: User '${userA}' successfully adding region '${regionNameSuccess}' to their map ${mapAFriendly}.`);
      const successResult = await painScoreConcept.addRegion({ user: userA, map: mapA, regionName: regionNameSuccess });
      assertEquals("error" in successResult, false, "Adding a region to an owned map should succeed.");
      const { region: newRegionId } = successResult as { region: ID };
      assertExists(newRegionId, "A new region ID should be returned on success.");
      const newRegionIdFriendly = getAbstractedId(newRegionId, 'region', regionNameSuccess);
      console.log(`  Output: New region created with friendly ID: ${newRegionIdFriendly}.`);

      // Verification: The new region exists in the user's map
      console.log(`  Verification: Checking if region ${newRegionIdFriendly} exists in map ${mapAFriendly}.`);
      const regions = await painScoreConcept._getRegionsForMap({ user: userA, map: mapA });
      assertNotEquals("error" in regions, true, "_getRegionsForMap should not fail.");
      const foundRegion = (regions as Array<any>).find((r) => r._id === newRegionId);
      assertExists(foundRegion, "The newly added region should be found in the map.");
      assertEquals(foundRegion.name, regionNameSuccess, "The name of the added region should match.");
      console.log(`  Verification: Region ${newRegionIdFriendly} confirmed in map ${mapAFriendly}.`);

      console.log("--- Action: addRegion Tests End ---");
    } finally {
      await client.close();
    }
  });

  await test.step("Action: scoreRegion requirements and effects", async () => {
    const [db, client] = await testDb();
    const bodyMapGen = new BodyMapGenerationConcept(db);
    const painScoreConcept = new PainLocationScoringConcept(db);

    try {
      console.log("\n--- Action: scoreRegion Tests Start ---");

      // Setup: Generate maps and add regions for userA and userB
      console.log(`  Setup: Initializing maps for user '${userA}' and user '${userB}'.`);
      const mapA = await setupMap(bodyMapGen, painScoreConcept, userA);
      const mapB = await setupMap(bodyMapGen, painScoreConcept, userB);
      const mapAFriendly = getAbstractedId(mapA, 'map');
      const mapBFriendly = getAbstractedId(mapB, 'map');

      const addRegionA1Result = await painScoreConcept.addRegion({ user: userA, map: mapA, regionName: "Forehead" });
      const { region: regionA1 } = addRegionA1Result as { region: ID };
      assertExists(regionA1);
      const regionA1Friendly = getAbstractedId(regionA1, 'region', "Forehead");
      console.log(`  Setup: Added region ${regionA1Friendly} to map ${mapAFriendly} for user '${userA}'.`);

      const addRegionB1Result = await painScoreConcept.addRegion({ user: userB, map: mapB, regionName: "Left Ankle" });
      const { region: regionB1 } = addRegionB1Result as { region: ID };
      assertExists(regionB1);
      const regionB1Friendly = getAbstractedId(regionB1, 'region', "Left Ankle");
      console.log(`  Setup: Added region ${regionB1Friendly} to map ${mapBFriendly} for user '${userB}'.`);

      // Test Case 1: Score a non-existent region ID
      const nonExistentRegion = "region:ghost" as ID;
      const nonExistentRegionFriendly = getAbstractedId(nonExistentRegion, 'region');
      console.log(`  Action: User '${userA}' attempts to score non-existent region ${nonExistentRegionFriendly}.`);
      const result1 = await painScoreConcept.scoreRegion({ user: userA, region: nonExistentRegion, score: 5 });
      assertEquals("error" in result1, true, "Expected error when scoring non-existent region.");
      assertEquals((result1 as { error: string }).error, `Region '${nonExistentRegion}' not found or not owned by user '${userA}'.`, "Error message mismatch for non-existent region.");
      console.log(`  Output: Error received: '${(result1 as { error: string }).error}' (Expected)`);

      // Test Case 2: Score a region not owned by the specified user
      console.log(`  Action: User '${userA}' attempts to score region ${regionB1Friendly} owned by '${userB}'.`);
      const result2 = await painScoreConcept.scoreRegion({ user: userA, region: regionB1, score: 8 });
      assertEquals("error" in result2, true, "Expected error when scoring another user's region.");
      assertEquals((result2 as { error: string }).error, `Region '${regionB1}' not found or not owned by user '${userA}'.`, "Error message mismatch for unowned region.");
      console.log(`  Output: Error received: '${(result2 as { error: string }).error}' (Expected)`);

      // Test Case 3: Score with a value less than 1
      console.log(`  Action: User '${userA}' attempts to score region ${regionA1Friendly} with value 0 (below min).`);
      const result3 = await painScoreConcept.scoreRegion({ user: userA, region: regionA1, score: 0 });
      assertEquals("error" in result3, true, "Expected error when scoring with value less than 1.");
      assertEquals((result3 as { error: string }).error, "Score must be a number between 1 and 10.", "Error message mismatch for score below min.");
      console.log(`  Output: Error received: '${(result3 as { error: string }).error}' (Expected)`);

      // Test Case 4: Score with a value greater than 10
      console.log(`  Action: User '${userA}' attempts to score region ${regionA1Friendly} with value 11 (above max).`);
      const result4 = await painScoreConcept.scoreRegion({ user: userA, region: regionA1, score: 11 });
      assertEquals("error" in result4, true, "Expected error when scoring with value greater than 10.");
      assertEquals((result4 as { error: string }).error, "Score must be a number between 1 and 10.", "Error message mismatch for score above max.");
      console.log(`  Output: Error received: '${(result4 as { error: string }).error}' (Expected)`);

      // Test Case 5: Successfully score a region
      const successScore = 6;
      console.log(`  Action: User '${userA}' successfully scoring region ${regionA1Friendly} with value ${successScore}.`);
      const successResult = await painScoreConcept.scoreRegion({ user: userA, region: regionA1, score: successScore });
      assertEquals("error" in successResult, false, "Scoring with a valid value on an owned region should succeed.");
      console.log(`  Output: Score updated for region ${regionA1Friendly}.`);

      // Verification: The region now has the assigned score
      console.log(`  Verification: Checking score for region ${regionA1Friendly}.`);
      const scoredRegion = await painScoreConcept._getRegion({ user: userA, region: regionA1 });
      assertNotEquals("error" in scoredRegion, true, "_getRegion should not fail after successful scoring.");
      assertEquals((scoredRegion as Array<any>).length, 1, "The scored region should be found.");
      assertEquals((scoredRegion as Array<any>)[0].score, successScore, `Region ${regionA1Friendly}'s score should be ${successScore}.`);
      console.log(`  Verification: Region ${regionA1Friendly} confirmed with score ${successScore}.`);

      // Test Case 6: Update an existing score
      const updatedScore = 9;
      console.log(`  Action: User '${userA}' updating score for region ${regionA1Friendly} to ${updatedScore}.`);
      const updateResult = await painScoreConcept.scoreRegion({ user: userA, region: regionA1, score: updatedScore });
      assertEquals("error" in updateResult, false, "Updating an existing score should succeed.");
      console.log(`  Output: Score updated for region ${regionA1Friendly}.`);

      // Verification: Updated score
      console.log(`  Verification: Checking updated score for region ${regionA1Friendly}.`);
      const updatedScoredRegion = await painScoreConcept._getRegion({ user: userA, region: regionA1 });
      assertNotEquals("error" in updatedScoredRegion, true, "_getRegion should not fail after updating score.");
      assertEquals((updatedScoredRegion as Array<any>)[0].score, updatedScore, `Region ${regionA1Friendly}'s score should be updated to ${updatedScore}.`);
      console.log(`  Verification: Region ${regionA1Friendly} confirmed updated to score ${updatedScore}.`);

      console.log("--- Action: scoreRegion Tests End ---");
    } finally {
      await client.close();
    }
  });

  await test.step("Action: deleteRegion requirements and effects", async () => {
    const [db, client] = await testDb();
    const bodyMapGen = new BodyMapGenerationConcept(db);
    const painScoreConcept = new PainLocationScoringConcept(db);

    try {
      console.log("\n--- Action: deleteRegion Tests Start ---");

      // Setup: Generate maps and add regions for userA and userB
      console.log(`  Setup: Initializing maps for user '${userA}' and user '${userB}'.`);
      const mapA = await setupMap(bodyMapGen, painScoreConcept, userA);
      const mapB = await setupMap(bodyMapGen, painScoreConcept, userB);
      const mapAFriendly = getAbstractedId(mapA, 'map');
      const mapBFriendly = getAbstractedId(mapB, 'map');

      const addRegionA1Result = await painScoreConcept.addRegion({ user: userA, map: mapA, regionName: "Right Elbow" });
      const { region: regionA1 } = addRegionA1Result as { region: ID };
      assertExists(regionA1);
      const regionA1Friendly = getAbstractedId(regionA1, 'region', "Right Elbow");
      console.log(`  Setup: Added region ${regionA1Friendly} to map ${mapAFriendly} for user '${userA}'.`);

      const addRegionA2Result = await painScoreConcept.addRegion({ user: userA, map: mapA, regionName: "Left Wrist" });
      const { region: regionA2 } = addRegionA2Result as { region: ID };
      assertExists(regionA2);
      const regionA2Friendly = getAbstractedId(regionA2, 'region', "Left Wrist");
      console.log(`  Setup: Added region ${regionA2Friendly} to map ${mapAFriendly} for user '${userA}'.`);

      const addRegionB1Result = await painScoreConcept.addRegion({ user: userB, map: mapB, regionName: "Nose" });
      const { region: regionB1 } = addRegionB1Result as { region: ID };
      assertExists(regionB1);
      const regionB1Friendly = getAbstractedId(regionB1, 'region', "Nose");
      console.log(`  Setup: Added region ${regionB1Friendly} to map ${mapBFriendly} for user '${userB}'.`);

      // Test Case 1: Delete a non-existent region ID
      const nonExistentRegion = "region:imaginary" as ID;
      const nonExistentRegionFriendly = getAbstractedId(nonExistentRegion, 'region');
      console.log(`  Action: User '${userA}' attempts to delete non-existent region ${nonExistentRegionFriendly}.`);
      const result1 = await painScoreConcept.deleteRegion({ user: userA, region: nonExistentRegion });
      assertEquals("error" in result1, true, "Expected error when deleting non-existent region.");
      assertEquals((result1 as { error: string }).error, `Region '${nonExistentRegion}' not found or not owned by user '${userA}'.`, "Error message mismatch for non-existent region.");
      console.log(`  Output: Error received: '${(result1 as { error: string }).error}' (Expected)`);

      // Test Case 2: Delete a region not owned by the specified user
      console.log(`  Action: User '${userA}' attempts to delete region ${regionB1Friendly} owned by '${userB}'.`);
      const result2 = await painScoreConcept.deleteRegion({ user: userA, region: regionB1 });
      assertEquals("error" in result2, true, "Expected error when deleting another user's region.");
      assertEquals((result2 as { error: string }).error, `Region '${regionB1}' not found or not owned by user '${userA}'.`, "Error message mismatch for unowned region.");
      console.log(`  Output: Error received: '${(result2 as { error: string }).error}' (Expected)`);

      // Test Case 3: Successfully delete an owned region
      console.log(`  Action: User '${userA}' successfully deleting region ${regionA1Friendly} from their map ${mapAFriendly}.`);
      const successResult = await painScoreConcept.deleteRegion({ user: userA, region: regionA1 });
      assertEquals("error" in successResult, false, "Deleting an owned region should succeed.");
      console.log(`  Output: Region ${regionA1Friendly} deleted.`);

      // Verification: The region no longer exists in the user's map
      console.log(`  Verification: Checking regions remaining in map ${mapAFriendly} after deletion.`);
      const regionsAfterDelete = await painScoreConcept._getRegionsForMap({ user: userA, map: mapA });
      assertNotEquals("error" in regionsAfterDelete, true, "_getRegionsForMap should not fail after deletion.");
      assertEquals((regionsAfterDelete as Array<any>).length, 1, "There should be one region left after deleting one.");
      assertEquals((regionsAfterDelete as Array<any>)[0]._id, regionA2, `The remaining region should be ${regionA2Friendly}.`);
      console.log(`  Verification: Region ${regionA1Friendly} confirmed deleted. Only ${regionA2Friendly} remains in map ${mapAFriendly}.`);

      console.log("--- Action: deleteRegion Tests End ---");
    } finally {
      await client.close();
    }
  });

  await test.step("Integrated Test: Multiple users and maps interact correctly and with proper isolation", async () => {
    const [db, client] = await testDb();
    const bodyMapGen = new BodyMapGenerationConcept(db);
    const painScoreConcept = new PainLocationScoringConcept(db);

    try {
      console.log("\n--- Integrated Test: Multiple User/Map Interaction ---");

      // Setup maps for User A and User B
      console.log(`  Setup: Initializing maps for user '${userA}' and user '${userB}'.`);
      const mapA = await setupMap(bodyMapGen, painScoreConcept, userA);
      const mapB = await setupMap(bodyMapGen, painScoreConcept, userB);
      const mapAFriendly = getAbstractedId(mapA, 'map');
      const mapBFriendly = getAbstractedId(mapB, 'map');

      // User A adds regions to their map
      console.log(`  Action: User '${userA}' adding regions to their map ${mapAFriendly}.`);
      const addRegionA1Result = await painScoreConcept.addRegion({ user: userA, map: mapA, regionName: "Left Hand" });
      const { region: regionA1 } = addRegionA1Result as { region: ID };
      const addRegionA2Result = await painScoreConcept.addRegion({ user: userA, map: mapA, regionName: "Right Hand" });
      const { region: regionA2 } = addRegionA2Result as { region: ID };
      assertExists(regionA1, `Region should exist.`); assertExists(regionA2, `Region should exist.`);
      const regionA1Friendly = getAbstractedId(regionA1, 'region', "Left Hand");
      const regionA2Friendly = getAbstractedId(regionA2, 'region', "Right Hand");
      console.log(`  Output: User '${userA}' added regions: ${regionA1Friendly}, ${regionA2Friendly}.`);

      // User B adds regions to their map
      console.log(`  Action: User '${userB}' adding regions to their map ${mapBFriendly}.`);
      const addRegionB1Result = await painScoreConcept.addRegion({ user: userB, map: mapB, regionName: "Left Foot" });
      const { region: regionB1 } = addRegionB1Result as { region: ID };
      assertExists(regionB1, `Region should exist.`);
      const regionB1Friendly = getAbstractedId(regionB1, 'region', "Left Foot");
      console.log(`  Output: User '${userB}' added region: ${regionB1Friendly}.`);

      // User A scores their regions
      console.log(`  Action: User '${userA}' scoring their regions in map ${mapAFriendly}.`);
      const scoreA1Result = await painScoreConcept.scoreRegion({ user: userA, region: regionA1, score: 5 });
      assertEquals("error" in scoreA1Result, false, "User A scoring own region should succeed.");
      const scoreA2Result = await painScoreConcept.scoreRegion({ user: userA, region: regionA2, score: 9 });
      assertEquals("error" in scoreA2Result, false, "User A scoring own region should succeed.");
      console.log(`  Output: User '${userA}' scored ${regionA1Friendly} (5), ${regionA2Friendly} (9).`);

      // User B scores their region
      console.log(`  Action: User '${userB}' scoring their region in map ${mapBFriendly}.`);
      const scoreB1Result = await painScoreConcept.scoreRegion({ user: userB, region: regionB1, score: 3 });
      assertEquals("error" in scoreB1Result, false, "User B scoring own region should succeed.");
      console.log(`  Output: User '${userB}' scored ${regionB1Friendly} (3).`);

      // Verification: User A's regions and scores
      console.log(`  Verification: Checking '${userA}'s regions and scores for map ${mapAFriendly}.`);
      const userARegions = await painScoreConcept._getRegionsForMap({ user: userA, map: mapA });
      assertNotEquals("error" in userARegions, true, `_getRegionsForMap for '${userA}' should not fail.`);
      assertEquals((userARegions as Array<any>).length, 2, `User '${userA}' should have 2 regions.`);
      assertEquals((userARegions as Array<any>).find(r => r._id === regionA1)?.score, 5, `Region ${regionA1Friendly} score for '${userA}' should be 5.`);
      assertEquals((userARegions as Array<any>).find(r => r._id === regionA2)?.score, 9, `Region ${regionA2Friendly} score for '${userA}' should be 9.`);
      console.log(`  Verification: User '${userA}' regions and scores verified successfully.`);

      // Verification: User B's regions and scores
      console.log(`  Verification: Checking '${userB}'s regions and scores for map ${mapBFriendly}.`);
      const userBRegions = await painScoreConcept._getRegionsForMap({ user: userB, map: mapB });
      assertNotEquals("error" in userBRegions, true, `_getRegionsForMap for '${userB}' should not fail.`);
      assertEquals((userBRegions as Array<any>).length, 1, `User '${userB}' should have 1 region.`);
      assertEquals((userBRegions as Array<any>).find(r => r._id === regionB1)?.score, 3, `Region ${regionB1Friendly} score for '${userB}' should be 3.`);
      console.log(`  Verification: User '${userB}' regions and scores verified successfully.`);

      // Attempt cross-user modification (should fail)
      console.log(`  Action: User '${userA}' attempts cross-user modification (score ${userB}'s region ${regionB1Friendly}).`);
      const crossScoreResult = await painScoreConcept.scoreRegion({ user: userA, region: regionB1, score: 10 });
      assertEquals("error" in crossScoreResult, true, "User A should not be able to score User B's region.");
      assertEquals((crossScoreResult as { error: string }).error, `Region '${regionB1}' not found or not owned by user '${userA}'.`, "Error message mismatch for cross-user scoring.");
      console.log(`  Output: Error received: '${(crossScoreResult as { error: string }).error}' (Expected: User A cannot score User B's region)`);

      console.log("--- Integrated Test: Multiple User/Map Interaction Complete ---");
    } finally {
      await client.close();
    }
  });
});
```

# prompt: Fix these errors from BodyMapGeneration testing.
BodyMapGeneration ... Principle: BodyMapGeneration Lifecycle => ./src/concepts/BodyMapGeneration/BodyMapGeneration.test.ts:22:14
error: AssertionError: Expected actual: "null" to not be null or undefined: User 1 state should exist after initial generation.
    throw new AssertionError(msg);
          ^
    at assertExists (https://jsr.io/@std/assert/1.0.15/exists.ts:29:11)
    at file:///Users/ananyaganesh/painpal_backend/src/concepts/BodyMapGeneration/BodyMapGeneration.test.ts:81:7
    at eventLoopTick (ext:core/01_core.js:179:7)
    at async innerWrapped (ext:cli/40_test.js:181:5)
    at async exitSanitizer (ext:cli/40_test.js:97:27)
    at async Object.outerWrapped [as fn] (ext:cli/40_test.js:124:14)
    at async TestContext.step (ext:cli/40_test.js:511:22)
    at async file:///Users/ananyaganesh/painpal_backend/src/concepts/BodyMapGeneration/BodyMapGeneration.test.ts:22:3

BodyMapGeneration ... Action: System generates a map for a new user correctly initializes their state => ./src/concepts/BodyMapGeneration/BodyMapGeneration.test.ts:474:14
error: AssertionError: Expected actual: "null" to not be null or undefined: User state should be created for the new user.
    throw new AssertionError(msg);
          ^
    at assertExists (https://jsr.io/@std/assert/1.0.15/exists.ts:29:11)
    at file:///Users/ananyaganesh/painpal_backend/src/concepts/BodyMapGeneration/BodyMapGeneration.test.ts:507:7
    at eventLoopTick (ext:core/01_core.js:179:7)
    at async innerWrapped (ext:cli/40_test.js:181:5)
    at async exitSanitizer (ext:cli/40_test.js:97:27)
    at async Object.outerWrapped [as fn] (ext:cli/40_test.js:124:14)
    at async TestContext.step (ext:cli/40_test.js:511:22)
    at async file:///Users/ananyaganesh/painpal_backend/src/concepts/BodyMapGeneration/BodyMapGeneration.test.ts:474:3

BodyMapGeneration ... Action: Generating a map twice for the same user on the same calendar day fails => ./src/concepts/BodyMapGeneration/BodyMapGeneration.test.ts:538:14
error: AssertionError: Expected actual: "null" to not be null or undefined: User state should exist after initial generation.
    throw new AssertionError(msg);
          ^
    at assertExists (https://jsr.io/@std/assert/1.0.15/exists.ts:29:11)
    at file:///Users/ananyaganesh/painpal_backend/src/concepts/BodyMapGeneration/BodyMapGeneration.test.ts:558:7
    at eventLoopTick (ext:core/01_core.js:179:7)
    at async innerWrapped (ext:cli/40_test.js:181:5)
    at async exitSanitizer (ext:cli/40_test.js:97:27)
    at async Object.outerWrapped [as fn] (ext:cli/40_test.js:124:14)
    at async TestContext.step (ext:cli/40_test.js:511:22)
    at async file:///Users/ananyaganesh/painpal_backend/src/concepts/BodyMapGeneration/BodyMapGeneration.test.ts:538:3

BodyMapGeneration ... Action: Saving a map fails if user has no current map => ./src/concepts/BodyMapGeneration/BodyMapGeneration.test.ts:610:14
error: AssertionError: Values are not equal: User's currentMapId should be null after clearing.


    [Diff] Actual / Expected


-   undefined
+   null

  throw new AssertionError(message);
        ^
    at assertEquals (https://jsr.io/@std/assert/1.0.15/equals.ts:65:9)
    at file:///Users/ananyaganesh/painpal_backend/src/concepts/BodyMapGeneration/BodyMapGeneration.test.ts:652:7
    at eventLoopTick (ext:core/01_core.js:179:7)
    at async innerWrapped (ext:cli/40_test.js:181:5)
    at async exitSanitizer (ext:cli/40_test.js:97:27)
    at async Object.outerWrapped [as fn] (ext:cli/40_test.js:124:14)
    at async TestContext.step (ext:cli/40_test.js:511:22)
    at async file:///Users/ananyaganesh/painpal_backend/src/concepts/BodyMapGeneration/BodyMapGeneration.test.ts:610:3

BodyMapGeneration ... Action: Clearing a map fails if user has no current map => ./src/concepts/BodyMapGeneration/BodyMapGeneration.test.ts:682:14
error: AssertionError: Initial clear operation should succeed to set currentMapId to null.
    throw new AssertionError(msg);
          ^
    at assert (https://jsr.io/@std/assert/1.0.15/assert.ts:21:11)
    at file:///Users/ananyaganesh/painpal_backend/src/concepts/BodyMapGeneration/BodyMapGeneration.test.ts:720:7
    at eventLoopTick (ext:core/01_core.js:179:7)
    at async innerWrapped (ext:cli/40_test.js:181:5)
    at async exitSanitizer (ext:cli/40_test.js:97:27)
    at async Object.outerWrapped [as fn] (ext:cli/40_test.js:124:14)
    at async TestContext.step (ext:cli/40_test.js:511:22)
    at async file:///Users/ananyaganesh/painpal_backend/src/concepts/BodyMapGeneration/BodyMapGeneration.test.ts:682:3

[@BodyMapGenerationTest](../../../src/concepts/BodyMapGeneration/BodyMapGeneration.test.ts)
[@BodyMapGenerationImplementation](../../../src/concepts/BodyMapGeneration/BodyMapGeneration.ts)