**Reflections Doc**

- What was hard or easy?

I think the easiest (or most exciting\!) part for me was Assignment 1, where I could come up with problem ideas. I really enjoyed the creative process and exploring my community for challenges to solve. It was initially difficult to identify whether each idea was actually a full-stack app with useful functionality or more of a frontend-heavy design with an exciting UI that made it feel compelling. Additionally, given that I’ve never worked on a full-stack app before, it was a bit of a steep learning curve to handle but I think the structure and sequence of the assignments made it feel more manageable\!

- What mistakes did you make, and how would you avoid making them in the future?

Initially, the main mistake I made was trying to complete parts of the app in bulk. It felt less intimidating to vibe-code things all at once than break them down into smaller steps. But, Assignment 4a in particular helped me work on problems in an incremental way and actually understand how to engineer both context and prompts to guide the LLM for the best possible results. I think this phased and detail-oriented approach is something that I will definitely use whenever I use LLMs to code (and even when I don’t\!).

- What skills did you acquire and which do you feel you still need to develop further?

Most of the material covered in this class was completely new to me. I found things like learning to differentiate concepts from features, and considering the conflation of concerns and concept independence incredibly useful when trying to design the app. I still feel like I need more experience with manual coding while thinking about the software design principles taught here. Although I took the option of vibe-coding to experience that (since I haven’t done that before either), I think it would be very useful to apply the same ideas when writing code on my own.

- How did you use the Context tool?

I used the Context tool both to brainstorm and incrementally generate pieces of code up to a certain point before turning to agentic coding. It was interesting to be able to view a log of my LLM interactions via the tool and it gave me a frame of reference for what I had already tried and what had not worked out. Although it was a little frustrating as it slowed down the pace of vibe-coding, I think it was a great exercise in  context engineering that really illustrated how I can thoughtfully use context to guide LLMs to produce more helpful output instead of a brute-force approach.

- How did you use an agentic coding tool? 

I primarily used an agentic coding tool on this project. I have never vibe-coded before this class so it was really fun and even fascinating to see it identify and fix some issues that I might not even have caught on my own. However, there were also several moments when it implemented completely unnecessary or erroneous changes that made it difficult for me to identify and eliminate since it would affect so many files in the codebase\! Overall, I still feel like there is a certain level of agency that handwritten code gives you which agentic coding simply cannot, no matter how much context or prompt engineering is done on our part.

- What conclusions can you draw about the role of LLMs in software development?

As I mentioned in the previous answer, I think relying too heavily on LLMs to create your codebase creates an imbalance in how well you truly know your ‘own’ code which can easily devolve into security breaches, production issues, etc. I think LLM-based coding should be more about using it for tedious tasks that do not require a heavy level of security, rather than creative development.