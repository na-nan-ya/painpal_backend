---
timestamp: 'Fri Oct 17 2025 21:26:12 GMT-0400 (Eastern Daylight Time)'
parent: '[[../20251017_212612.5faf8f79.md]]'
content_id: 5e267514fe8f17fa12e3abd62d117a6b73552f622e87105fd0d320c86139897a
---

# response:

```typescript
import { assertEquals, assertExists, assertNotEquals } from "jsr:@std/assert";
import { testDb } from "@utils/database.ts";
import { ID } from "@utils/types.ts";
import PainLocationScoringConcept from "./PainLocationScoringConcept.ts";
import BodyMapGenerationConcept from "../BodyMapGeneration/BodyMapGeneration.ts";

// Define generic user IDs for testing
const userA = "user:Alice" as ID;
const userB = "user:Bob" as ID;

/**
 * Helper function to simulate the integrated process of generating a map via
 * BodyMapGeneration and then making PainLocationScoringConcept aware of it
 * for its internal ownership validation.
 * This simulates the effect of a synchronization rule where PainLocationScoring
 * becomes aware of maps generated by BodyMapGeneration.
 *
 * @param bodyMapGen The BodyMapGenerationConcept instance.
 * @param painScoreConcept The PainLocationScoringConcept instance.
 * @param user The user ID for whom the map is generated.
 * @returns The ID of the generated map.
 */
async function setupMap(
  bodyMapGen: BodyMapGenerationConcept,
  painScoreConcept: PainLocationScoringConcept,
  user: ID,
): Promise<ID> {
  // 1. Generate map via BodyMapGeneration
  console.log(`  Setup: Generating map for user ${user}...`);
  const generateMapResult = await bodyMapGen.generateMap({ user });
  assertNotEquals("error" in generateMapResult, true, `Map generation for ${user} should succeed.`);
  const { mapId } = generateMapResult as { mapId: ID };
  console.log(`  Setup: Generated map ${mapId} for user ${user}.`);

  // 2. Register this map with PainLocationScoring for its internal validation.
  // This uses the _addMapForTesting helper, acting as a mock for a cross-concept sync.
  const registerMapResult = await painScoreConcept._addMapForTesting({ user, map: mapId });
  assertEquals("error" in registerMapResult, false, `Setup: Registering map ${mapId} with PainLocationScoring for user ${user} should succeed.`);
  console.log(`  Setup: Registered map ${mapId} with PainLocationScoring.`);
  return mapId;
}

Deno.test("Principle: Generate map → add region → score region → delete region → verify state at each step", async (test) => {
  const [db, client] = await testDb();
  const bodyMapGen = new BodyMapGenerationConcept(db);
  const painScoreConcept = new PainLocationScoringConcept(db);

  await test.step("BodyMapGeneration Lifecycle", async () => {
    try {
      console.log("\n--- Principle: PainLocationScoring Lifecycle ---");

      // Action: Generate map for User A using BodyMapGeneration
      console.log("  Principle: Generating and registering a map for User A.");
      const mapA = await setupMap(bodyMapGen, painScoreConcept, userA);
      assertExists(mapA, "A map ID should be returned for user A.");
      console.log(`  Output: Map ${mapA} created for ${userA}.`);

      // Action: Add a region to User A's map
      const regionName = "Left Knee";
      console.log(`  Principle: Adding region '${regionName}' to map ${mapA}.`);
      const addRegionResult = await painScoreConcept.addRegion({ user: userA, map: mapA, regionName });
      assertNotEquals("error" in addRegionResult, true, "addRegion should not fail.");
      const { region: regionA } = addRegionResult as { region: ID };
      assertExists(regionA, "A region ID should be returned.");
      console.log(`  Output: New Region ID: ${regionA}.`);

      // Verification: The region was added
      console.log(`  Principle: Verifying region ${regionA} was added.`);
      const regionsAfterAdd = await painScoreConcept._getRegionsForMap({ user: userA, map: mapA });
      assertNotEquals("error" in regionsAfterAdd, true, "_getRegionsForMap should not fail.");
      assertEquals((regionsAfterAdd as Array<any>).length, 1, "There should be exactly one region after adding.");
      assertEquals((regionsAfterAdd as Array<any>)[0]._id, regionA, "The added region's ID should match.");
      assertEquals((regionsAfterAdd as Array<any>)[0].name, regionName, "The added region's name should match.");
      console.log(`  Verification: Region ${regionA} (${regionName}) successfully added to map ${mapA}.`);

      // Action: Score the region for User A
      const scoreValue = 7;
      console.log(`  Principle: Scoring region ${regionA} with value ${scoreValue}.`);
      const scoreRegionResult = await painScoreConcept.scoreRegion({ user: userA, region: regionA, score: scoreValue });
      assertEquals("error" in scoreRegionResult, false, "scoreRegion should succeed.");
      console.log(`  Output: Region ${regionA} scored with ${scoreValue}.`);

      // Verification: The score was applied
      console.log(`  Principle: Verifying score for region ${regionA}.`);
      const scoredRegion = await painScoreConcept._getRegion({ user: userA, region: regionA });
      assertNotEquals("error" in scoredRegion, true, "_getRegion should not fail after scoring.");
      assertEquals((scoredRegion as Array<any>).length, 1, "The scored region should be found.");
      assertEquals((scoredRegion as Array<any>)[0].score, scoreValue, `The region's score should be ${scoreValue}.`);
      console.log(`  Verification: Region ${regionA} now has score ${scoreValue}.`);

      // Action: Delete the region for User A
      console.log(`  Principle: Deleting region ${regionA}.`);
      const deleteRegionResult = await painScoreConcept.deleteRegion({ user: userA, region: regionA });
      assertEquals("error" in deleteRegionResult, false, "deleteRegion should succeed.");
      console.log(`  Output: Region ${regionA} deleted.`);

      // Verification: The region is deleted
      console.log(`  Principle: Verifying region ${regionA} is deleted.`);
      const regionsAfterDelete = await painScoreConcept._getRegionsForMap({ user: userA, map: mapA });
      assertNotEquals("error" in regionsAfterDelete, true, "_getRegionsForMap should not fail after deletion attempt.");
      assertEquals((regionsAfterDelete as Array<any>).length, 0, "There should be no regions after deletion.");
      console.log(`  Verification: Region ${regionA} successfully deleted from map ${mapA}.`);

      console.log("--- Principle: PainLocationScoring Lifecycle Complete ---");
    } finally {
      await client.close();
    }
  });
});

Deno.test("Action: addRegion requirements and effects", async (test) => {
  const [db, client] = await testDb();
  const bodyMapGen = new BodyMapGenerationConcept(db);
  const painScoreConcept = new PainLocationScoringConcept(db);

  await test.step("Requirements: Map ownership and existence", async () => {
    try {
      console.log("\n--- Action: addRegion Tests Start ---");

      // Setup: Generate maps for userA and userB and register them
      const mapA = await setupMap(bodyMapGen, painScoreConcept, userA);
      const mapB = await setupMap(bodyMapGen, painScoreConcept, userB);

      // Test Case 1: Add region to a non-existent map ID
      const nonExistentMap = "map:nonexistent" as ID;
      console.log(`  Action: User ${userA} attempts to add region to non-existent map '${nonExistentMap}'.`);
      const result1 = await painScoreConcept.addRegion({ user: userA, map: nonExistentMap, regionName: "Phantom Limb" });
      assertEquals("error" in result1, true, "Expected error when adding to non-existent map.");
      assertEquals((result1 as { error: string }).error, `Map '${nonExistentMap}' not found for user '${userA}' or user does not own it.`, "Error message mismatch for non-existent map.");
      console.log(`  Output: Error received: ${JSON.stringify(result1.error)} (Expected)`);

      // Test Case 2: Add region to a map not owned by the specified user
      console.log(`  Action: User ${userA} attempts to add region to map ${mapB} owned by ${userB}.`);
      const result2 = await painScoreConcept.addRegion({ user: userA, map: mapB, regionName: "Stolen Map Region" });
      assertEquals("error" in result2, true, "Expected error when adding to another user's map.");
      assertEquals((result2 as { error: string }).error, `Map '${mapB}' not found for user '${userA}' or user does not own it.`, "Error message mismatch for unowned map.");
      console.log(`  Output: Error received: ${JSON.stringify(result2.error)} (Expected)`);

      // Test Case 3: Successfully add a region to an owned map
      const regionNameSuccess = "Right Shoulder";
      console.log(`  Action: User ${userA} successfully adding region '${regionNameSuccess}' to their map ${mapA}.`);
      const successResult = await painScoreConcept.addRegion({ user: userA, map: mapA, regionName: regionNameSuccess });
      assertEquals("error" in successResult, false, "Adding a region to an owned map should succeed.");
      const { region: newRegionId } = successResult as { region: ID };
      assertExists(newRegionId, "A new region ID should be returned on success.");
      console.log(`  Output: New Region ID: ${newRegionId}.`);

      // Verification: The new region exists in the user's map
      console.log(`  Verification: Checking if region ${newRegionId} exists in map ${mapA}.`);
      const regions = await painScoreConcept._getRegionsForMap({ user: userA, map: mapA });
      assertNotEquals("error" in regions, true, "_getRegionsForMap should not fail.");
      const foundRegion = (regions as Array<any>).find((r) => r._id === newRegionId);
      assertExists(foundRegion, "The newly added region should be found in the map.");
      assertEquals(foundRegion.name, regionNameSuccess, "The name of the added region should match.");
      console.log(`  Verification: Region ${newRegionId} (${regionNameSuccess}) confirmed in map ${mapA}.`);

      console.log("--- Action: addRegion Tests End ---");
    } finally {
      await client.close();
    }
  });
});

Deno.test("Action: scoreRegion requirements and effects", async (test) => {
  const [db, client] = await testDb();
  const bodyMapGen = new BodyMapGenerationConcept(db);
  const painScoreConcept = new PainLocationScoringConcept(db);

  await test.step("Requirements: Region existence, ownership, and score validation", async () => {
    try {
      console.log("\n--- Action: scoreRegion Tests Start ---");

      // Setup: Generate maps and add regions for userA and userB
      const mapA = await setupMap(bodyMapGen, painScoreConcept, userA);
      const mapB = await setupMap(bodyMapGen, painScoreConcept, userB);

      const addRegionA1Result = await painScoreConcept.addRegion({ user: userA, map: mapA, regionName: "Forehead" });
      const { region: regionA1 } = addRegionA1Result as { region: ID };
      assertExists(regionA1);
      console.log(`  Setup: Added region ${regionA1} (Forehead) to map ${mapA} for user ${userA}.`);

      const addRegionB1Result = await painScoreConcept.addRegion({ user: userB, map: mapB, regionName: "Left Ankle" });
      const { region: regionB1 } = addRegionB1Result as { region: ID };
      assertExists(regionB1);
      console.log(`  Setup: Added region ${regionB1} (Left Ankle) to map ${mapB} for user ${userB}.`);

      // Test Case 1: Score a non-existent region ID
      const nonExistentRegion = "region:ghost" as ID;
      console.log(`  Action: User ${userA} attempts to score non-existent region '${nonExistentRegion}'.`);
      const result1 = await painScoreConcept.scoreRegion({ user: userA, region: nonExistentRegion, score: 5 });
      assertEquals("error" in result1, true, "Expected error when scoring non-existent region.");
      assertEquals((result1 as { error: string }).error, `Region '${nonExistentRegion}' not found or not owned by user '${userA}'.`, "Error message mismatch for non-existent region.");
      console.log(`  Output: Error received: ${JSON.stringify(result1.error)} (Expected)`);

      // Test Case 2: Score a region not owned by the specified user
      console.log(`  Action: User ${userA} attempts to score region ${regionB1} owned by ${userB}.`);
      const result2 = await painScoreConcept.scoreRegion({ user: userA, region: regionB1, score: 8 });
      assertEquals("error" in result2, true, "Expected error when scoring another user's region.");
      assertEquals((result2 as { error: string }).error, `Region '${regionB1}' not found or not owned by user '${userA}'.`, "Error message mismatch for unowned region.");
      console.log(`  Output: Error received: ${JSON.stringify(result2.error)} (Expected)`);

      // Test Case 3: Score with a value less than 1
      console.log(`  Action: User ${userA} attempts to score region ${regionA1} with value 0 (below min).`);
      const result3 = await painScoreConcept.scoreRegion({ user: userA, region: regionA1, score: 0 });
      assertEquals("error" in result3, true, "Expected error when scoring with value less than 1.");
      assertEquals((result3 as { error: string }).error, "Score must be a number between 1 and 10.", "Error message mismatch for score below min.");
      console.log(`  Output: Error received: ${JSON.stringify(result3.error)} (Expected)`);

      // Test Case 4: Score with a value greater than 10
      console.log(`  Action: User ${userA} attempts to score region ${regionA1} with value 11 (above max).`);
      const result4 = await painScoreConcept.scoreRegion({ user: userA, region: regionA1, score: 11 });
      assertEquals("error" in result4, true, "Expected error when scoring with value greater than 10.");
      assertEquals((result4 as { error: string }).error, "Score must be a number between 1 and 10.", "Error message mismatch for score above max.");
      console.log(`  Output: Error received: ${JSON.stringify(result4.error)} (Expected)`);

      // Test Case 5: Successfully score a region
      const successScore = 6;
      console.log(`  Action: User ${userA} successfully scoring region ${regionA1} with value ${successScore}.`);
      const successResult = await painScoreConcept.scoreRegion({ user: userA, region: regionA1, score: successScore });
      assertEquals("error" in successResult, false, "Scoring with a valid value on an owned region should succeed.");
      console.log(`  Output: Score updated for region ${regionA1}.`);

      // Verification: The region now has the assigned score
      console.log(`  Verification: Checking score for region ${regionA1}.`);
      const scoredRegion = await painScoreConcept._getRegion({ user: userA, region: regionA1 });
      assertNotEquals("error" in scoredRegion, true, "_getRegion should not fail after successful scoring.");
      assertEquals((scoredRegion as Array<any>).length, 1, "The scored region should be found.");
      assertEquals((scoredRegion as Array<any>)[0].score, successScore, `Region ${regionA1}'s score should be ${successScore}.`);
      console.log(`  Verification: Region ${regionA1} confirmed with score ${successScore}.`);

      // Test Case 6: Update an existing score
      const updatedScore = 9;
      console.log(`  Action: User ${userA} updating score for region ${regionA1} to ${updatedScore}.`);
      const updateResult = await painScoreConcept.scoreRegion({ user: userA, region: regionA1, score: updatedScore });
      assertEquals("error" in updateResult, false, "Updating an existing score should succeed.");
      console.log(`  Output: Score updated for region ${regionA1}.`);

      // Verification: Updated score
      console.log(`  Verification: Checking updated score for region ${regionA1}.`);
      const updatedScoredRegion = await painScoreConcept._getRegion({ user: userA, region: regionA1 });
      assertNotEquals("error" in updatedScoredRegion, true, "_getRegion should not fail after updating score.");
      assertEquals((updatedScoredRegion as Array<any>)[0].score, updatedScore, `Region ${regionA1}'s score should be updated to ${updatedScore}.`);
      console.log(`  Verification: Region ${regionA1} confirmed updated to score ${updatedScore}.`);

      console.log("--- Action: scoreRegion Tests End ---");
    } finally {
      await client.close();
    }
  });
});

Deno.test("Action: deleteRegion requirements and effects", async (test) => {
  const [db, client] = await testDb();
  const bodyMapGen = new BodyMapGenerationConcept(db);
  const painScoreConcept = new PainLocationScoringConcept(db);

  await test.step("Requirements: Region existence and ownership", async () => {
    try {
      console.log("\n--- Action: deleteRegion Tests Start ---");

      // Setup: Generate maps and add regions for userA and userB
      const mapA = await setupMap(bodyMapGen, painScoreConcept, userA);
      const mapB = await setupMap(bodyMapGen, painScoreConcept, userB);

      const addRegionA1Result = await painScoreConcept.addRegion({ user: userA, map: mapA, regionName: "Right Elbow" });
      const { region: regionA1 } = addRegionA1Result as { region: ID };
      assertExists(regionA1);
      console.log(`  Setup: Added region ${regionA1} (Right Elbow) to map ${mapA} for user ${userA}.`);

      const addRegionA2Result = await painScoreConcept.addRegion({ user: userA, map: mapA, regionName: "Left Wrist" });
      const { region: regionA2 } = addRegionA2Result as { region: ID };
      assertExists(regionA2);
      console.log(`  Setup: Added region ${regionA2} (Left Wrist) to map ${mapA} for user ${userA}.`);

      const addRegionB1Result = await painScoreConcept.addRegion({ user: userB, map: mapB, regionName: "Nose" });
      const { region: regionB1 } = addRegionB1Result as { region: ID };
      assertExists(regionB1);
      console.log(`  Setup: Added region ${regionB1} (Nose) to map ${mapB} for user ${userB}.`);

      // Test Case 1: Delete a non-existent region ID
      const nonExistentRegion = "region:imaginary" as ID;
      console.log(`  Action: User ${userA} attempts to delete non-existent region '${nonExistentRegion}'.`);
      const result1 = await painScoreConcept.deleteRegion({ user: userA, region: nonExistentRegion });
      assertEquals("error" in result1, true, "Expected error when deleting non-existent region.");
      assertEquals((result1 as { error: string }).error, `Region '${nonExistentRegion}' not found or not owned by user '${userA}'.`, "Error message mismatch for non-existent region.");
      console.log(`  Output: Error received: ${JSON.stringify(result1.error)} (Expected)`);

      // Test Case 2: Delete a region not owned by the specified user
      console.log(`  Action: User ${userA} attempts to delete region ${regionB1} owned by ${userB}.`);
      const result2 = await painScoreConcept.deleteRegion({ user: userA, region: regionB1 });
      assertEquals("error" in result2, true, "Expected error when deleting another user's region.");
      assertEquals((result2 as { error: string }).error, `Region '${regionB1}' not found or not owned by user '${userA}'.`, "Error message mismatch for unowned region.");
      console.log(`  Output: Error received: ${JSON.stringify(result2.error)} (Expected)`);

      // Test Case 3: Successfully delete an owned region
      console.log(`  Action: User ${userA} successfully deleting region ${regionA1} from their map ${mapA}.`);
      const successResult = await painScoreConcept.deleteRegion({ user: userA, region: regionA1 });
      assertEquals("error" in successResult, false, "Deleting an owned region should succeed.");
      console.log(`  Output: Region ${regionA1} deleted.`);

      // Verification: The region no longer exists in the user's map
      console.log(`  Verification: Checking regions remaining in map ${mapA} after deletion.`);
      const regionsAfterDelete = await painScoreConcept._getRegionsForMap({ user: userA, map: mapA });
      assertNotEquals("error" in regionsAfterDelete, true, "_getRegionsForMap should not fail after deletion.");
      assertEquals((regionsAfterDelete as Array<any>).length, 1, "There should be one region left after deleting one.");
      assertEquals((regionsAfterDelete as Array<any>)[0]._id, regionA2, "The remaining region should be regionA2.");
      console.log(`  Verification: Region ${regionA1} confirmed deleted. Only ${regionA2} remains in map ${mapA}.`);

      console.log("--- Action: deleteRegion Tests End ---");
    } finally {
      await client.close();
    }
  });
});

Deno.test("Integrated Test: Multiple users and maps interact correctly and with proper isolation", async (test) => {
  const [db, client] = await testDb();
  const bodyMapGen = new BodyMapGenerationConcept(db);
  const painScoreConcept = new PainLocationScoringConcept(db);

  await test.step("Interaction: Ensuring proper data isolation and modification for multiple users", async () => {
    try {
      console.log("\n--- Integrated Test: Multiple User/Map Interaction ---");

      // Setup maps for User A and User B
      console.log(`  Setup: Initializing maps for ${userA} and ${userB}.`);
      const mapA = await setupMap(bodyMapGen, painScoreConcept, userA);
      const mapB = await setupMap(bodyMapGen, painScoreConcept, userB);

      // User A adds regions to their map
      console.log(`  Action: User ${userA} adding regions to their map ${mapA}.`);
      const addRegionA1Result = await painScoreConcept.addRegion({ user: userA, map: mapA, regionName: "Left Hand" });
      const { region: regionA1 } = addRegionA1Result as { region: ID };
      const addRegionA2Result = await painScoreConcept.addRegion({ user: userA, map: mapA, regionName: "Right Hand" });
      const { region: regionA2 } = addRegionA2Result as { region: ID };
      assertExists(regionA1, `Region ${regionA1} should exist.`); assertExists(regionA2, `Region ${regionA2} should exist.`);
      console.log(`  Output: User ${userA} added regions: ${regionA1} (Left Hand), ${regionA2} (Right Hand).`);

      // User B adds regions to their map
      console.log(`  Action: User ${userB} adding regions to their map ${mapB}.`);
      const addRegionB1Result = await painScoreConcept.addRegion({ user: userB, map: mapB, regionName: "Left Foot" });
      const { region: regionB1 } = addRegionB1Result as { region: ID };
      assertExists(regionB1, `Region ${regionB1} should exist.`);
      console.log(`  Output: User ${userB} added region: ${regionB1} (Left Foot).`);

      // User A scores their regions
      console.log(`  Action: User ${userA} scoring their regions in map ${mapA}.`);
      const scoreA1Result = await painScoreConcept.scoreRegion({ user: userA, region: regionA1, score: 5 });
      assertEquals("error" in scoreA1Result, false, "User A scoring own region should succeed.");
      const scoreA2Result = await painScoreConcept.scoreRegion({ user: userA, region: regionA2, score: 9 });
      assertEquals("error" in scoreA2Result, false, "User A scoring own region should succeed.");
      console.log(`  Output: User ${userA} scored ${regionA1} (5), ${regionA2} (9).`);

      // User B scores their region
      console.log(`  Action: User ${userB} scoring their region in map ${mapB}.`);
      const scoreB1Result = await painScoreConcept.scoreRegion({ user: userB, region: regionB1, score: 3 });
      assertEquals("error" in scoreB1Result, false, "User B scoring own region should succeed.");
      console.log(`  Output: User ${userB} scored ${regionB1} (3).`);

      // Verification: User A's regions and scores
      console.log(`  Verification: Checking ${userA}'s regions and scores for map ${mapA}.`);
      const userARegions = await painScoreConcept._getRegionsForMap({ user: userA, map: mapA });
      assertNotEquals("error" in userARegions, true, `_getRegionsForMap for ${userA} should not fail.`);
      assertEquals((userARegions as Array<any>).length, 2, `User ${userA} should have 2 regions.`);
      assertEquals((userARegions as Array<any>).find(r => r._id === regionA1)?.score, 5, `Region ${regionA1} score for ${userA} should be 5.`);
      assertEquals((userARegions as Array<any>).find(r => r._id === regionA2)?.score, 9, `Region ${regionA2} score for ${userA} should be 9.`);
      console.log(`  Verification: User ${userA} regions and scores verified successfully.`);

      // Verification: User B's regions and scores
      console.log(`  Verification: Checking ${userB}'s regions and scores for map ${mapB}.`);
      const userBRegions = await painScoreConcept._getRegionsForMap({ user: userB, map: mapB });
      assertNotEquals("error" in userBRegions, true, `_getRegionsForMap for ${userB} should not fail.`);
      assertEquals((userBRegions as Array<any>).length, 1, `User ${userB} should have 1 region.`);
      assertEquals((userBRegions as Array<any>).find(r => r._id === regionB1)?.score, 3, `Region ${regionB1} score for ${userB} should be 3.`);
      console.log(`  Verification: User ${userB} regions and scores verified successfully.`);

      // Attempt cross-user modification (should fail)
      console.log(`  Action: User ${userA} attempts cross-user modification (score ${userB}'s region ${regionB1}).`);
      const crossScoreResult = await painScoreConcept.scoreRegion({ user: userA, region: regionB1, score: 10 });
      assertEquals("error" in crossScoreResult, true, "User A should not be able to score User B's region.");
      assertEquals((crossScoreResult as { error: string }).error, `Region '${regionB1}' not found or not owned by user '${userA}'.`, "Error message mismatch for cross-user scoring.");
      console.log(`  Output: Error received: ${JSON.stringify(crossScoreResult.error)} (Expected: User A cannot score User B's region)`);

      console.log("--- Integrated Test: Multiple User/Map Interaction Complete ---");
    } finally {
      await client.close();
    }
  });
});
```
