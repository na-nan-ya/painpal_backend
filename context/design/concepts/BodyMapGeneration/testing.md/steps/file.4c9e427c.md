---
timestamp: 'Fri Oct 17 2025 12:50:25 GMT-0400 (Eastern Daylight Time)'
parent: '[[../20251017_125025.c5002f57.md]]'
content_id: 4c9e427c0a050796a8724f9649d027be2d33432593a02d94771aa91f50a1f1d5
---

# file: src/BodyMapGeneration/BodyMapGenerationConcept.test.ts

```typescript
// src/BodyMapGeneration/BodyMapGenerationConcept.test.ts
import { assertEquals, assertRejects, assert } from "jsr:@std/assert";
import { DB } from "https://deno.land/x/sqlite@v3.4.0/mod.ts"; // Assuming SQLite for testDb mock

// Mock for @utils/database.ts:
// This function simulates `testDb` by creating an in-memory SQLite database
// and initializing its schema. It provides a fresh, clean database for each test.
export const testDb = async (): Promise<[DB, { close: () => Promise<void> }]> => {
  const db = new DB(":memory:"); // In-memory SQLite database
  db.query(`
    CREATE TABLE IF NOT EXISTS BodyMap (
      id TEXT PRIMARY KEY,
      name TEXT NOT NULL,
      type TEXT NOT NULL,
      version INTEGER DEFAULT 1,
      createdAt TEXT DEFAULT CURRENT_TIMESTAMP,
      updatedAt TEXT DEFAULT CURRENT_TIMESTAMP
    );
  `);
  db.query(`
    CREATE TABLE IF NOT EXISTS BodyRegion (
      id TEXT PRIMARY KEY,
      bodyMapId TEXT NOT NULL,
      name TEXT NOT NULL,
      description TEXT,
      boundingCoordinates TEXT,
      createdAt TEXT DEFAULT CURRENT_TIMESTAMP,
      updatedAt TEXT DEFAULT CURRENT_TIMESTAMP,
      FOREIGN KEY (bodyMapId) REFERENCES BodyMap(id) ON DELETE CASCADE
    );
  `);
  db.query(`
    CREATE TABLE IF NOT EXISTS BodyPoint (
      id TEXT PRIMARY KEY,
      bodyMapId TEXT NOT NULL,
      bodyRegionId TEXT,
      name TEXT NOT NULL,
      coordinates TEXT NOT NULL,
      type TEXT,
      metadata TEXT,
      createdAt TEXT DEFAULT CURRENT_TIMESTAMP,
      updatedAt TEXT DEFAULT CURRENT_TIMESTAMP,
      FOREIGN KEY (bodyMapId) REFERENCES BodyMap(id) ON DELETE CASCADE,
      FOREIGN KEY (bodyRegionId) REFERENCES BodyRegion(id) ON DELETE CASCADE
    );
  `);
  const client = {
    close: async () => db.close(),
  };
  return [db, client];
};

// Import the functions to be tested from the implementation module
import {
  addBodyPoint,
  addBodyRegion,
  createBodyMap,
  getBodyMapDetails,
  BodyMap,
  BodyRegion,
} from "./BodyMapGeneration.ts";

Deno.test("BodyMapGeneration Concept Testing", async (t) => {
  # trace: Demonstrates how the principle "A Body Map can be generated by defining its overall structure,
  # trace: then progressively adding specific regions and points, ensuring all components are logically linked and retrievable as a complete, hierarchical structure."
  # trace: is fulfilled.
  # trace: 1. `createBodyMap`: Initialize a base Body Map (e.g., "Human Female").
  # trace: 2. `addBodyRegion`: Add multiple regions to this Body Map (e.g., "Head", "Torso").
  # trace: 3. `addBodyPoint`: Add points, some directly to the map, some to specific regions (e.g., "Navel" to map, "Nose Tip" to Head, "Heart Center" to Torso).
  # trace: 4. `getBodyMapDetails`: Verify the complete, hierarchical structure of the generated Body Map.

  await t.step("Action: createBodyMap - requires and effects", async (st) => {
    const [db, client] = await testDb();
    try {
      st.step("requires: name and type must be provided", async () => {
        await assertRejects(
          () => createBodyMap(db, "", "anatomical"),
          Error,
          "Name and type are required",
          "Should reject if name is empty",
        );
        await assertRejects(
          () => createBodyMap(db, "Human Male", ""),
          Error,
          "Name and type are required",
          "Should reject if type is empty",
        );
      });

      st.step("effects: A new BodyMap record is created", async () => {
        const bodyMap = await createBodyMap(db, "Human Male", "anatomical");
        assert(bodyMap.id, "Body map should have an ID");
        assertEquals(bodyMap.name, "Human Male");
        assertEquals(bodyMap.type, "anatomical");
        assertEquals(bodyMap.version, 1);

        const retrieved = db.query<
          [string, string, string, number]
        >(
          "SELECT id, name, type, version FROM BodyMap WHERE id = ?",
          [bodyMap.id],
        );
        assertEquals(retrieved.length, 1, "Body map should be retrievable from DB");
        assertEquals(retrieved[0][0], bodyMap.id);
        assertEquals(retrieved[0][1], "Human Male");
      });
    } finally {
      await client.close();
    }
  });

  await t.step("Action: addBodyRegion - requires and effects", async (st) => {
    const [db, client] = await testDb();
    let bodyMap: BodyMap;
    try {
      bodyMap = await createBodyMap(db, "Human Male", "anatomical");

      st.step("requires: bodyMapId and name must be provided", async () => {
        await assertRejects(
          () => addBodyRegion(db, "", "Head"),
          Error,
          "Body map ID and name are required",
          "Should reject if bodyMapId is empty",
        );
        await assertRejects(
          () => addBodyRegion(db, bodyMap.id, ""),
          Error,
          "Body map ID and name are required",
          "Should reject if name is empty",
        );
      });

      st.step("effects: A new BodyRegion record is created and linked", async () => {
        const region = await addBodyRegion(
          db,
          bodyMap.id,
          "Head",
          "Upper part of the body",
          "[[0,0,10],[10,0,10],[10,10,10],[0,10,10]]",
        );
        assert(region.id, "Region should have an ID");
        assertEquals(region.bodyMapId, bodyMap.id);
        assertEquals(region.name, "Head");
        assertEquals(region.description, "Upper part of the body");
        assertEquals(region.boundingCoordinates, "[[0,0,10],[10,0,10],[10,10,10],[0,10,10]]");

        const retrieved = db.query<
          [string, string, string]
        >(
          "SELECT id, bodyMapId, name FROM BodyRegion WHERE id = ?",
          [region.id],
        );
        assertEquals(retrieved.length, 1, "Body region should be retrievable from DB");
        assertEquals(retrieved[0][0], region.id);
        assertEquals(retrieved[0][1], bodyMap.id);
      });
    } finally {
      await client.close();
    }
  });

  await t.step("Action: addBodyPoint - requires and effects", async (st) => {
    const [db, client] = await testDb();
    let bodyMap: BodyMap;
    let region: BodyRegion;
    try {
      bodyMap = await createBodyMap(db, "Human Male", "anatomical");
      region = await addBodyRegion(db, bodyMap.id, "Head");

      st.step("requires: bodyMapId, name, coordinates must be provided and valid", async () => {
        await assertRejects(
          () => addBodyPoint(db, "", "Nose", "[0,0,0]"),
          Error,
          "Body map ID, name, and coordinates are required",
          "Should reject if bodyMapId is empty",
        );
        await assertRejects(
          () => addBodyPoint(db, bodyMap.id, "", "[0,0,0]"),
          Error,
          "Body map ID, name, and coordinates are required",
          "Should reject if name is empty",
        );
        await assertRejects(
          () => addBodyPoint(db, bodyMap.id, "Nose", ""),
          Error,
          "Body map ID, name, and coordinates are required",
          "Should reject if coordinates are empty",
        );
        await assertRejects(
          () => addBodyPoint(db, bodyMap.id, "Nose", "invalid-json"),
          Error,
          "Coordinates must be a valid JSON array string",
          "Should reject if coordinates are not valid JSON",
        );
        await assertRejects(
          () => addBodyPoint(db, bodyMap.id, "Nose", '["a","b"]'),
          Error,
          "Coordinates must be a JSON array of numbers",
          "Should reject if coordinates are not numbers",
        );
      });

      st.step("effects: A new BodyPoint record is created and linked", async () => {
        // Point directly to map
        const point1 = await addBodyPoint(
          db,
          bodyMap.id,
          "Navel",
          "[0,0,0]",
          undefined, // no region
          "landmark",
          '{"color":"red"}',
        );
        assert(point1.id, "Point 1 should have an ID");
        assertEquals(point1.bodyMapId, bodyMap.id);
        assertEquals(point1.name, "Navel");
        assertEquals(point1.coordinates, "[0,0,0]");
        assertEquals(point1.type, "landmark");
        assertEquals(point1.metadata, '{"color":"red"}');
        assertEquals(point1.bodyRegionId, undefined);

        // Point within a region
        const point2 = await addBodyPoint(
          db,
          bodyMap.id,
          "Nose Tip",
          "[0,5,10]",
          region.id, // linked to region
          "landmark",
        );
        assert(point2.id, "Point 2 should have an ID");
        assertEquals(point2.bodyMapId, bodyMap.id);
        assertEquals(point2.bodyRegionId, region.id);
        assertEquals(point2.name, "Nose Tip");
        assertEquals(point2.coordinates, "[0,5,10]");
        assertEquals(point2.type, "landmark");
        assertEquals(point2.metadata, undefined);

        const retrieved1 = db.query<
          [string, string, string, string]
        >(
          "SELECT id, bodyMapId, name, coordinates FROM BodyPoint WHERE id = ?",
          [point1.id],
        );
        assertEquals(retrieved1.length, 1, "Body point 1 should be retrievable from DB");
        assertEquals(retrieved1[0][0], point1.id);
        assertEquals(retrieved1[0][1], bodyMap.id);

        const retrieved2 = db.query<
          [string, string, string | null, string]
        >(
          "SELECT id, bodyMapId, bodyRegionId, name FROM BodyPoint WHERE id = ?",
          [point2.id],
        );
        assertEquals(retrieved2.length, 1, "Body point 2 should be retrievable from DB");
        assertEquals(retrieved2[0][0], point2.id);
        assertEquals(retrieved2[0][1], bodyMap.id);
        assertEquals(retrieved2[0][2], region.id);
      });
    } finally {
      await client.close();
    }
  });

  await t.step("Action: getBodyMapDetails - requires, effects, and principle fulfillment", async (st) => {
    const [db, client] = await testDb();
    try {
      st.step("requires: bodyMapId must be provided and exist", async () => {
        const result = await getBodyMapDetails(db, "non-existent-id");
        assertEquals(result, null, "Should return null for non-existent ID");
      });

      st.step("effects & principle: Returns a BodyMap object including nested regions and points", async () => {
        // Step 1: Create a base Body Map
        const bodyMap = await createBodyMap(db, "Human Female", "anatomical");

        // Step 2: Add multiple regions to this Body Map
        const regionHead = await addBodyRegion(db, bodyMap.id, "Head", "Cranium and face");
        const regionTorso = await addBodyRegion(db, bodyMap.id, "Torso", "Trunk of the body");

        // Step 3: Add points, some directly to the map, some to specific regions
        const pointNavel = await addBodyPoint(db, bodyMap.id, "Navel", "[0,0,-5]", undefined, "landmark");
        const pointNose = await addBodyPoint(db, bodyMap.id, "Nose Tip", "[0,5,10]", regionHead.id, "landmark");
        const pointHeart = await addBodyPoint(db, bodyMap.id, "Heart Center", "[0,0,0]", regionTorso.id, "organ_center");

        // Step 4: Verify the complete structure of the generated Body Map
        const retrievedBodyMap = await getBodyMapDetails(db, bodyMap.id);

        assert(retrievedBodyMap, "Retrieved body map should not be null");
        assertEquals(retrievedBodyMap.id, bodyMap.id);
        assertEquals(retrievedBodyMap.name, "Human Female");
        assertEquals(retrievedBodyMap.type, "anatomical");

        // Verify regions
        assertEquals(retrievedBodyMap.regions.length, 2, "Should have 2 regions");
        const headRegion = retrievedBodyMap.regions.find((r) => r.id === regionHead.id);
        assert(headRegion, "Head region should be present");
        assertEquals(headRegion.name, "Head");
        assertEquals(headRegion.bodyMapId, bodyMap.id);

        const torsoRegion = retrievedBodyMap.regions.find((r) => r.id === regionTorso.id);
        assert(torsoRegion, "Torso region should be present");
        assertEquals(torsoRegion.name, "Torso");
        assertEquals(torsoRegion.bodyMapId, bodyMap.id);

        // Verify points
        assertEquals(retrievedBodyMap.points.length, 3, "Should have 3 points");
        const navelPoint = retrievedBodyMap.points.find((p) => p.id === pointNavel.id);
        assert(navelPoint, "Navel point should be present");
        assertEquals(navelPoint.name, "Navel");
        assertEquals(navelPoint.bodyMapId, bodyMap.id);
        assertEquals(navelPoint.bodyRegionId, undefined, "Navel should not be in a region");
        assertEquals(navelPoint.coordinates, "[0,0,-5]");

        const nosePoint = retrievedBodyMap.points.find((p) => p.id === pointNose.id);
        assert(nosePoint, "Nose point should be present");
        assertEquals(nosePoint.name, "Nose Tip");
        assertEquals(nosePoint.bodyMapId, bodyMap.id);
        assertEquals(nosePoint.bodyRegionId, regionHead.id);
        assertEquals(nosePoint.coordinates, "[0,5,10]");

        const heartPoint = retrievedBodyMap.points.find((p) => p.id === pointHeart.id);
        assert(heartPoint, "Heart point should be present");
        assertEquals(heartPoint.name, "Heart Center");
        assertEquals(heartPoint.bodyMapId, bodyMap.id);
        assertEquals(heartPoint.bodyRegionId, regionTorso.id);
        assertEquals(heartPoint.coordinates, "[0,0,0]");
      });
    } finally {
      await client.close();
    }
  });
});
```
