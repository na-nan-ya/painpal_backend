---
timestamp: 'Fri Oct 17 2025 12:53:46 GMT-0400 (Eastern Daylight Time)'
parent: '[[../20251017_125346.7cb48386.md]]'
content_id: 6fb87da4b3a1aec4a5519c910fd4cda948ed9d508878bc030a92329699568631
---

# Test implementation

First, let's define the dummy implementation that will be tested. This would normally reside in `src/BodyMapGeneration/BodyMapGeneration.ts` or similar.

```typescript
// src/BodyMapGeneration/BodyMapGeneration.ts
import { Client } from "https://deno.land/x/postgres@v0.17.0/mod.ts"; // Assuming @utils/database.ts returns this client type

// Interfaces for data models
interface BodyMap {
  id: string;
  userId: string;
  name: string;
  createdAt: Date;
}

interface BodyMapRegion {
  id: string;
  bodyMapId: string;
  name: string;
  data: Record<string, unknown>;
  createdAt: Date;
}

interface BodyMapWithRegions extends BodyMap {
  regions: BodyMapRegion[];
}

/**
 * Service for generating and managing user body maps and their regions.
 */
class BodyMapGenerationService {
  private client: Client;

  constructor(client: Client) {
    this.client = client;
  }

  /**
   * Creates a new body map for a given user.
   * @param userId The ID of the user.
   * @param name The name of the body map.
   * @returns The ID of the new body map, or an error object.
   */
  async createBodyMap(userId: string, name: string): Promise<{ id: string } | { error: string }> {
    if (!userId || typeof userId !== 'string' || userId.trim() === '') {
      return { error: "User ID is required." };
    }
    if (!name || typeof name !== 'string' || name.trim() === '') {
      return { error: "Body map name is required." };
    }

    try {
      // Check for unique name for the user
      const existingMaps = await this.client.queryObject<{ count: number }>(
        `SELECT COUNT(*) FROM body_maps WHERE user_id = $1 AND name = $2`,
        userId, name
      );

      if (existingMaps.rows[0].count > 0) {
        return { error: `A body map with name '${name}' already exists for user '${userId}'.` };
      }

      const result = await this.client.queryObject<{ id: string }>(
        `INSERT INTO body_maps (user_id, name) VALUES ($1, $2) RETURNING id`,
        userId, name
      );
      return { id: result.rows[0].id };
    } catch (e) {
      console.error("Error creating body map:", e);
      return { error: `Failed to create body map: ${e.message}` };
    }
  }

  /**
   * Adds a region to an existing body map.
   * @param bodyMapId The ID of the body map.
   * @param regionName The name of the region (e.g., "Left Arm").
   * @param data Arbitrary JSON data associated with the region (e.g., coordinates, notes).
   * @returns The ID of the new region, or an error object.
   */
  async addRegionToBodyMap(bodyMapId: string, regionName: string, data: Record<string, unknown>): Promise<{ id: string } | { error: string }> {
    if (!bodyMapId || typeof bodyMapId !== 'string' || bodyMapId.trim() === '') {
      return { error: "Body map ID is required." };
    }
    if (!regionName || typeof regionName !== 'string' || regionName.trim() === '') {
      return { error: "Region name is required." };
    }
    if (typeof data !== 'object' || data === null) {
      return { error: "Region data must be an object." };
    }

    try {
      // Check if body map exists
      const mapExists = await this.client.queryObject<{ count: number }>(
        `SELECT COUNT(*) FROM body_maps WHERE id = $1`,
        bodyMapId
      );
      if (mapExists.rows[0].count === 0) {
        return { error: `Body map with ID '${bodyMapId}' not found.` };
      }

      // Check for unique region name within the body map
      const existingRegions = await this.client.queryObject<{ count: number }>(
        `SELECT COUNT(*) FROM body_map_regions WHERE body_map_id = $1 AND name = $2`,
        bodyMapId, regionName
      );
      if (existingRegions.rows[0].count > 0) {
        return { error: `A region with name '${regionName}' already exists in body map '${bodyMapId}'.` };
      }

      const result = await this.client.queryObject<{ id: string }>(
        `INSERT INTO body_map_regions (body_map_id, name, data) VALUES ($1, $2, $3::jsonb) RETURNING id`,
        bodyMapId, regionName, JSON.stringify(data)
      );
      return { id: result.rows[0].id };
    } catch (e) {
      console.error("Error adding region to body map:", e);
      return { error: `Failed to add region: ${e.message}` };
    }
  }

  /**
   * Retrieves a specific body map along with all its associated regions.
   * @param bodyMapId The ID of the body map to retrieve.
   * @returns The body map with regions, null if not found, or an error object.
   */
  async getBodyMapWithRegions(bodyMapId: string): Promise<BodyMapWithRegions | null | { error: string }> {
    if (!bodyMapId || typeof bodyMapId !== 'string' || bodyMapId.trim() === '') {
      return { error: "Body map ID is required." };
    }

    try {
      const mapResult = await this.client.queryObject<BodyMap>(
        `SELECT id, user_id AS "userId", name, created_at AS "createdAt" FROM body_maps WHERE id = $1`,
        bodyMapId
      );

      if (mapResult.rows.length === 0) {
        return null; // Body map not found
      }

      const bodyMap = mapResult.rows[0];

      const regionsResult = await this.client.queryObject<BodyMapRegion>(
        `SELECT id, body_map_id AS "bodyMapId", name, data, created_at AS "createdAt" FROM body_map_regions WHERE body_map_id = $1 ORDER BY name`,
        bodyMapId
      );

      // Ensure 'data' field is parsed from JSONB if it's stored as string
      const regions = regionsResult.rows.map(row => ({
          ...row,
          data: typeof row.data === 'string' ? JSON.parse(row.data) : row.data
      }));


      return {
        ...bodyMap,
        regions: regions
      };
    } catch (e) {
      console.error("Error getting body map with regions:", e);
      return { error: `Failed to retrieve body map: ${e.message}` };
    }
  }

  /**
   * Lists all body maps for a given user.
   * @param userId The ID of the user.
   * @returns An array of body maps, or an error object.
   */
  async listUserBodyMaps(userId: string): Promise<BodyMap[] | { error: string }> {
    if (!userId || typeof userId !== 'string' || userId.trim() === '') {
      return { error: "User ID is required." };
    }

    try {
      const result = await this.client.queryObject<BodyMap>(
        `SELECT id, user_id AS "userId", name, created_at AS "createdAt" FROM body_maps WHERE user_id = $1 ORDER BY name`,
        userId
      );
      return result.rows;
    } catch (e) {
      console.error("Error listing user body maps:", e);
      return { error: `Failed to list body maps: ${e.message}` };
    }
  }
}
```

***
